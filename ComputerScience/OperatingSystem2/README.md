# **OperatingSystem2** 💿

### 참고자료

- 운영체제와 정보기술의 원리 (반효경 저)
- KOCW 강의 [링크](http://www.kocw.net/home/search/kemView.do?kemId=1046323)

## 목차
>- [운영체제](#운영체제)
>>- [운영체제란](#운영체제란)
>>- [운영체제의 분류](#운영체제의-분류)
>- [시스템 구조 및 프로그램 실행](#시스템-구조-및-프로그램-실행)
>>- [컴퓨터 시스템 구조](#컴퓨터-시스템-구조)
>- [프로세스](#프로세스)
>>- [프로세스의 개념](#프로세스의-개념)
>>- [프로세스의 상태](#프로세스의-상태)
>>- [Process Control Block (PCB)](#process-control-block-pcb)
>>- [문맥 교환 (Context Switch)](#문맥-교환-context-switch)
>>- [프로세스를 스케줄링하기 위한 큐](#프로세스를-스케줄링하기-위한-큐)
>>- [스케줄러 (Scheduler)](#스케줄러-scheduler)
>>- [스레드 (Thread)](#스레드-thread)
>- [프로세스 관리](#프로세스-관리)
>>- [프로세스 생성](#프로세스-생성)
>>- [프로세스 종료](#프로세스-종료)
>>- [프로세스와 관련한 시스템 콜](#프로세스와-관련한-시스템-콜)
>>- [프로세스 간 협력](#프로세스-간-협력)
>- [CPU 스케줄링](#cpu-스케줄링)
>>- [CPU 스케줄링 개요](#cpu-스케줄링-개요)
>>- [CPU 스케줄링 알고리즘 종류](#cpu-스케줄링-알고리즘-종류)
>>- [스케줄링 성능 척도](#스케줄링-성능-척도)
>>- [멀티 프로세서 스케줄링](#멀티-프로세서-스케줄링)
>>- [실시간 스케줄링](#실시간-스케줄링)
>>- [스레드 스케줄링](#스레드-스케줄링)
>>- [알고리즘 평가방법](#알고리즘-평가방법)
>- [프로세스 동기화](#프로세스-동기화)
>>- [프로세스 동기화 개요](#프로세스-동기화-개요)


<br>

---

## 운영체제

>### 운영체제란
>- 운영체제(Operating System, OS)란
>>- 컴퓨터 하드웨어 바로 위에 설치되어 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층
>>- 한마디로 컴퓨터 시스템의 자원을 효율적으로 관리하는것, 자원 관리자
>- 운영체제의 목표
>>- 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공
>>>- 운영체제는 동시 사용자/프로그램들이 각각 독자적 컴퓨터에서 수행되는것 같은 환경을 제공
>>>- 하드웨어를 직접 다루는 복잡한 부분을 운영체제가 대행
>>- 컴퓨터 시스템의 자원을 효율적으로 관리
>>>- 프로세서, 기억장치, 입출력 장치 등의 효율적 관리
>>>>- 사용자간의 형평성 있는 자원 분배
>>>>- 주어진 자원으로 최대한의 성능을 내도록
>>>- 사용자 및 운영체제 자신의 보호
>>>- 프로세스, 파일, 메시지 등을 관리

<br>

[목차로 이동](#목차)

>### 운영체제의 분류
>- 동시 작업 가능 여부
>>- 단일 작업(single ttasking)
>>>- MS-DOS 프롬프트 상에서는 한 명령의 수행을 끝내기 전에 다른 명령을 수행시킬 수 없음
>>- 다중 작업(multi tasking)
>>>- UNIX, MS Windows 등에서는 한 명령의 수행이 끝나기 전에 다른 명령이나 프로그램을 수행할 수 있음
>- 사용자의 수
>>- 단일 사용자
>>>- MS-DOS, MS Windows
>>- 다중 사용자
>>>- UNIX, NT server
>- 처리 방식
>>- 일괄 처리(batch processing)
>>>- 작업 요청의 일정량을 모아서 한꺼번에 처리
>>>- 작업이 완전 종료될 때까지 기다려야 함
>>- 시분할(time sharing)
>>>- 여러 작업을 수행할 때 컴퓨터 처리 능력을 일정한 시간 단위로 분할하여 사용
>>>- 일괄 처리 시스템에 비해 짧은 응답 시간을 가짐
>>- 실시간(Realtime OS)
>>>- 정해진 시간 안에 어떠한 일이 반드시 종료됨이 보장되어야하는 실시간 시스템을 위한 OS
>>>- 예) 원자로/공장 제어, 미사일 제어, 반도체 장비, 로보트 제어

<br>

[목차로 이동](#목차)

---

## 시스템 구조 및 프로그램 실행

>### 컴퓨터 시스템 구조
>- Mode bit
>>- 사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호 장치
>>- Mode bit를 통해 하드웨어적으로 두 가지의 operation 모드 지원
>>>- 1 사용자 모드 : 사용자 프로그램 수행
>>>- 0 모니터 모드(커널 모드, 시스템 모드) : OS 코드 수행
>>- 보안을 해칠 수 있는 중요한 명령어는 모니터 모드에서만 수행 가능한 특권명령으로 규정
>>- Interrupt나 Exception 발생시 하드웨어가 mode bit를 0으로 바꿈
>>- 사용자 프로그램에게 CPU를 넘기기 전에 mode bit를 1로 세팅
>- 타이머
>>- 동작
>>>- 정해진 시간이 흐른 뒤 운영체제에게 제어권이 넘어가도록 인터럽트를 발생시킴
>>>- 타이머는 매 클럭 틱마다 1씩 감소
>>>- 타이머 값이 0이 되면 타이머 인터럽트 발생
>>>- CPU를 특정 프로그램이 독점하는 것으로부터 보호
>>- 타이머는 time sharing을 구현하기 위해 널리 이용됨
>>- 타이머는 현재 시간을 계산하기 위해서도 사용
>- Device Controller
>>- I/O device controller
>>>- 해당 I/O 장치유형을 관리하는 일종의 작은 CPU
>>>- 제어 정보를 위해 control register, status register를 가짐
>>>- local buffer를 가짐 (일종의 data register)
>>- I/O는 실제 device와 local buffer 사이에서 일어남
>>- Device controller는 I/O가 끝났을 경우 interrupt로 CPU에 그 사실을 알림
>>- 알아두기
>>>- devide driver : 장치 구동기
>>>>- OS 코드 중 각 장치별 처리루틴 -> software
>>>- device controller : 장치 제어기
>>>>- 각 장치를 통제하는 일종의 작은 CPU -> hardware
>- 입출력(I/O)의 수행
>>- 모든 입출력 명령은 특권 명령
>>- 사용자 프로그램의 I/O 방법
>>>- 시스템콜(system call)
>>>>- 사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것
>>>>- 사용자 프로그램은 운영체제에게 I/O 요청
>>>- trap을 사용하여 인터럽트 벡터의 특정 위치로 이동
>>>- 제어권이 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동
>>>- 올바은 I/O 요청인지 확인 후 I/O 수행
>>>- I/O 완료 시 제어권을 시스템콜 다음 명려으로 옮김
>- 인터럽트(Interrupt)
>>- 인터럽트
>>>- 인터럽트 당한 시점의 레지스터와 program counter를 save한 후 CPU의 제어를 인터럽트 처리 루틴에 넘김
>>- Interrupt (넓은 의미)
>>>- Interrupt (하드웨어 인터럽트) : 하드웨어가 발생시킨 인터럽트
>>>- Trap (소프트웨어 인터럽트)
>>>>- Exception : 프로그램이 오류를 범한 경우
>>>>- System call : 프로그램이 커널 함수를 호출하는 경우
>>- 인터럽트 관련 용어
>>>- 인터럽트 벡터
>>>>- 해당 인터럽트의 처리 루틴 주소를 가지고 있음
>>>- 인터럽트 처리 루틴 (Interrupt Service Routine, 인터럽트 핸들러)
>>>>- 해당 인터럽트를 처리하는 커널 함수
>- DMA (Direct Memory Access)
>>- 빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용
>>- CPU의 중재 없이 device controller가 device의 buffer storage의 내용을 메모리에 block 단위로 직접 전송
>>- 바이트 단위가 아니라 block 단위로 인터럽트를 발생시킴

<br>

[목차로 이동](#목차)

---

## 프로세스

>### 프로세스의 개념
>- 프로세스는 하나의 실행중인 프로그램
>- 프로세스 문맥(context)
>>- CPU 수행 상태를 나타내는 하드웨어 문맥
>>>- Program Counter
>>>- 각종 register
>>- 프로세스의 주소 공간
>>>- code, data, stack
>>- 프로세스 관련 커널 자료 구조
>>>- PCB(Process Control Block)
>>>- Kernel stack

<br>

[목차로 이동](#목차)

>### 프로세스의 상태
>- 프로세스는 상태(state)가 변경되며 수행됨
>>- Running
>>>- CPU를 잡고 instruction을 수행중인 상태
>>- Ready
>>>- CPU를 기다리는 상태(메모리 등 다른 조건을 모두 만족하고)
>>- Blocked (wait, sleep)
>>>- CPU를 주어도 당장 instruction을 수행할 수 없는 상태
>>>- Process 자신이 요청한 event(I/O 등)가 즉시 만족되지 않아 이를 기다리는 상태
>>>- 예) 디스크에서 file을 읽어와야 하는 경우
>>- Suspended (stopped)
>>>- 외부적인 이유로 프로세스의 수행이 정지된 상태
>>>- 프로세스는 통째로 디스크에 swap out 됨
>>>- 예시
>>>>- 사용자가 프로그램을 일시 정지시킨 경우(break key)
>>>>- 시스템이 여러 이유로 프로세스를 잠시 중단시킴(메모리에 너무 많은 프로세스가 올라와 있을 때)
>>- New : 프로세스가 생성중인 상태
>>- Terminated : 수행(execution)이 끝난 상태
>>- Blocked : 자신이 요청한 event가 만족되면 Ready
>>- Suspended : 외부에서 resume해 주어야 Active

<br>

[목차로 이동](#목차)

>### Process Control Block (PCB)
>- PCB
>>- 운영체제가 각 프로세스를 관리하기 위해 프로세스당 유지하는 정보
>>- 구성요소(구조체로 유지)
>>>1. OS가 관리상 사용하는 정보
>>>>- Process state, Process ID
>>>>- scheduling information, priority
>>>2. CPU 수행 관련 하드웨어 값
>>>>- Program counter, registers
>>>3. 메모리 관련
>>>>- Code, data, stack의 위치 정보
>>>4. 파일 관련
>>>>- Open file descriptors

<br>

[목차로 이동](#목차)

>### 문맥 교환 (Context Switch)
>- CPU를 한 프로세스에서 다른 프로세스로 넘겨주는 과정
>- CPU가 다른 프로세스에게 넘어갈 때 운영체제는 다음을 수행
>>- CPU를 내어주는 프로세스의 상태를 그 프로세스의 PCB에 저장
>>- CPU를 새롭게 얻는 프로세스의 상태를 PCB에서 읽어옴

<br>

[목차로 이동](#목차)

>### 프로세스를 스케줄링하기 위한 큐
>- Job queue
>>- 현재 시스템 내에 있는 모든 프로세스의 집합
>- Ready queue
>>- 현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합
>- Device queue
>>- I/O device의 처리를 기다리는 프로세스의 집합
>- 프로세스들은 각 큐들을 오가며 수행됨

<br>

[목차로 이동](#목차)

>### 스케줄러 (Scheduler)
>- Long-term scheduler (장기 스케줄러 or job scheduler)
>>- 시작 프로세스 중 어떤 것들을 ready queue로 보낼지 결정
>>- 프로세스에 memory(및 각종 자원)을 주는 문제
>>- time sharing system에는 보통 장기 스케줄러가 없음(무조건 ready)
>- Short-term scheduler (단기 스케줄러 or CPU scheduler)
>>- 어떤 프로세스를 다음 번에 running 시킬지 결정
>>- 프로세스에 CPU를 주는 문제
>>- 충분히 빨라야 함(millisecond 단위)
>- Medium-term scheduler (중기 스케줄러 or Swapper)
>>- 여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫓아냄
>>- 프로세스에게서 memory를 뺏는 문제

<br>

[목차로 이동](#목차)

>### 스레드 (Thread)
>- 개요
>>- 스레드 (또는 경량 프로세스)는 CPU 사용의 기본 단위임
>>- 스레드의 구성
>>>- program counter
>>>- register set
>>>- stack space
>>- 스레드가 동료 스레드와 공유하는 부분(=task)
>>>- code section
>>>- data section
>>>- OS resources
>>- 전통적인 개념의 heavyweight process는 하나의 thread를 가지고 있는 task로 볼 수 있음
>>- 다중 스레드로 구성된 태스크 구조에서는 하나의 서버 스레드가 blocked(waiting) 상태인 동안에도 동일한 태스크 내의 다른 스레드가 실행(running)되어 빠른 처리를 할 수 있음
>>- 동일한 일을 수행하는 다중 스레드가 협력하여 높은 처리율(throughtput)과 성능 향상을 얻을 수 있음
>>- 스레드를 사용하면 병렬성을 높일 수 있음
>- 장점
>>- 사용자 입장에서 응답이 빠름
>>- 자원을 공유하여 효율적임
>>- 프로세스를 추가로 만드는 것보다 스레드를 하나 추가하는 것이 경제적임
>>- 멀티프로세서 환경에서 효율적인 실행이 가능함
>- 스레드 구현법
>>- 커널에 의해 지원되는 방식은 커널 스레드
>>- 라이브러리에 의해 지원되는 방식은 유저 스레드

<br>

[목차로 이동](#목차)

---

## 프로세스 관리

>### 프로세스 생성
>- 부모 프로세스가 자식 프로세스를 생성
>- 프로세스의 트리(계층 구조)형성
>- 프로세스는 자원을 필요로 함
>>- 운영체제로부터 받음
>>- 부모와 공유함
>- 자원의 공유
>>- 부모의 자식이 모든 자원을 공유하는 모델
>>- 일부를 공유하는 모델
>>- 전혀 공유하지 않는 모델
>- 수행(Execution)
>>- 부모와 자식은 공존하며 수행되는 모델
>>- 자식이 종료(terminate)될 때까지 부모가 기다리는(wait) 모델
>- 주소 공간(Address space)
>>- 자식은 부모의 공간을 복사함
>>- 자식은 그 공간에 새로운 프로그램을 올림
>- 유닉스의 예
>>- fork() 시스템 콜이 새로운 프로세스를 생성
>>>- 부모를 그대로 복사 (OS data except PID + binary)
>>>- 주소 공간 할당
>>- fork 다음에 이어지는 exec() 시스템 콜을 통해 새로운 프로그램을 메모리에 올림

<br>

[목차로 이동](#목차)

>### 프로세스 종료
>- 프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알림(exit)
>>- 자식이 부모에게 output data를 보냄 (via wait)
>>- 프로세스의 각 종 자원들이 운영체제에게 반납됨
>- 부모 프로세스가 자식의 수행을 종료시킴(abort)
>>- 자식이 할당 자원의 한계치를 넘어섬
>>- 자식에게 할당된 태스크가 더 이상 필요하지 않음
>>- 부모가 종료(exit)하는 경우
>>>- 운영체제는 부모 프로세스가 종료하는 경우 자식이 더 이상 수행되도록 두지 않음
>>>- 단계적인 종료

<br>

[목차로 이동](#목차)

>### 프로세스와 관련한 시스템 콜
>- fork()
>>- create a child (copy)
>- exec()
>>- overlay new image
>- wait()
>>- sleep until child is done
>- exit()
>>- frees all the resources, notify parent

<br>

[목차로 이동](#목차)

>### 프로세스 간 협력
>- 개요
>>- 독립적 프로세스(Independent process)
>>>- 프로세스는 각자의 주소 공간을 가지고 수행되므로 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미치지 못함
>>- 협력 프로세스(Cooperating process)
>>>- 프로세스 협력 메커니즘을 통해 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있음
>>- 프로세스 간 협력 매커니즘 (IPC: Interprocess Communication)
>>>- 메시지를 전달하는 방법
>>>>- message passing : 커널을 통해 메시지 전달
>>>- 주소 공간을 공유하는 방법
>>>>- shared memory : 서로 다른 프로세스 간에도 일부 주소 공간을 공유하게 하는 메커니즘
>>>>- thread : thread는 사실상 하나의 프로세스이므로 프로세스 간 협력으로 보기는 어렵지만 동일한 process를 구성하는 thread 간에는 주소 공간을 공유하므로 협력이 가능

<br>

[목차로 이동](#목차)

---

## CPU 스케줄링

>### CPU 스케줄링 개요
>- CPU 버스트, I/O 버스트
>>- 프로그램이 실행될때는 CPU 인스트럭션을 실행하는 단계, IO 작업을 하는 단계를 번갈아가면서 진행됨
>>- CPU 버스트가 짧은 프로그램은 사람과 상호작용이 잦은 프로그램임
>>- CPU 스케줄링이란 레디큐의 프로세스중에서 어떤 프로세스에 CPU를 줄것인지 결정하는것
>- CPU 스케줄링 결정요소
>>- 비선점 - 한번 줬으면 계속 쓰게할것인가
>>- 선점 - 한번 주고 안쓸때는 다른 CPU에 넘길것이냐, 현대 운영체제에서는 대부분 선점식

<br>

[목차로 이동](#목차)

>### CPU 스케줄링 알고리즘 종류
>- FCFS(First come First Served) - 비선점형
>>- 먼저 요청한 프로세스가 먼저 CPU 버스트를 가짐
>>- FIFO 큐를 이용하여 쉽게 관리됨, 평균 대기시간이 대단히 길어질 수 있으므로 효율적이진 않음
>- SJF(Shortest Job First) - 비선점형
>>- 가장 작은 CPU 버스트를 가진 프로세스가 먼저 CPU 버스트를 가짐
>>- 최소 평균 대기 시간이 보장됨
>- SRTF(Shortest-Remaining Time First) - 선점형
>>- 남은 버스트 time보다 더 짧은 CPU 버스트 time을 가지는 새로운 프로세스가 도착하면 CPU를 빼앗김
>- SJF와 SRTF의 문제는 CPU 버스트의 길이를 알 수 없기 때문에 CPU 스케줄링 수준에서는 구현할 수 없고, 과거의 CPU 버스트의 소요시간을 통한 예측 근삿값을 통해 구현됨
>- Priority Scheduling - 선점형 또는 비선점형
>>- 우선순위가 가장 높은 프로세스에게 CPU 버스트를 넘긴다
>>- 낮은 우선순위의 프로세스들이 무한히 대기하는 무한 봉쇄 또는 기아 상태가 발생할 수 있는 문제가 있음
>>- 오랫동안 시스템에서 대기하는 프로세스들의 우선순위를 점진적으로 증가시키는 노화를 통해 해결할 수 있음
>- RR(Round Robin) - 선점형
>>- 모든 프로세스에 동일한 시간을 할당
>>- 할당 시간이 끝나면 프로세스는 레디큐의 제일 뒤로 밀려남
>>- 응답시간은 빠르지만 프로세스의 크기에 따라 완료시간이 느려질 수 있음
>>- 프로세스가 전환될 때 컨텍스트 스위칭이 이루어지므로 오버헤드가 커지는 문제가 있음
>- Multilevel Queue
>>- 레디큐를 여러개로 분할
>>>- foreground (interactive) - RR
>>>>- 사람과 상호작용이기때문에 응답시간이 중요하므로 RR
>>>- background (batch - no human interaction) - FCFS
>>>>- CPU만 오랫동안 사용하는 프로세스들이고 응답시간이 중요하지 않으므로 컨텍스트 스위칭 오버헤드를 줄이기위해 FCFS
>>- 큐에대한 스케줄링이 필요
>>>- 고정된 우선순위이므로 적절하게 시간배분을 하지않으면 기아상태 발생가능성이 있음
>>>- 일반적으로 foreground에 80%, background에 20% 할당
>- Multilevel Feedback Queue
>>- Multilevel Queue에서는 프로세스들이 영구적으로 하나의 큐에 할당되므로 융통성이 적음
>>- 프로세스가 다른 큐로 이동 가능, 노화를 이와 같은 방식으로 구현할 수 있음
>>- Multilevel Feedback Queue를 정의하는 매개변수
>>>- 큐의 개수
>>>- 각 큐의 스케줄링 알고리즘
>>>- 프로세스를 상위 큐로 보내는 기준
>>>- 프로세스를 하위 큐로 내쫓는 기준
>>>- 프로세스가 CPU 서비스를 받으려할 때 들어갈 큐를 결정하는 기준

<br>

[목차로 이동](#목차)

>### 스케줄링 성능 척도
>- CPU utilization (이용률) : CPU를 최대한 굴려야한다
>- Throughput (처리량) : 시간당 완료된 프로세스의 개수
>- Turnaround time (소요시간, 변경시간) : 프로세스의 제출시간과 완료 시간의 간격
>- Wating time (대기 시간) : 준비큐에서 얼마나 기다렸느냐
>- Response time (응답 시간) : 하나의 요구를 제출한 후 첫 번째 응답이 나올 때까지의 시간
>>- 응답 시간은 응답을 출력하는 데 걸리는 시간이 아닌 응답이 시작되는 데까지 걸리는 시간임

<br>

[목차로 이동](#목차)

>### 멀티 프로세서 스케줄링
>- 개요
>>- CPU가 여러 개인 경우 스케줄링은 더욱 복잡해짐
>>- Homogeneous processor (대칭 코어 프로세서)
>>>- Queue에 한 줄로 세워서 각 프로세서에가 알아서 꺼내가게 할 수 있음
>>>- 반드시 특정 프로세서에서 수행되어야 하는 프로세스가 있는 경우에 문제가 복잡해짐
>>- Load sharing (부하 균등화)
>>>- 일부 프로세서에 job이 몰리지 않도록 부하를 적절히 공유하는 메커니즘 필요
>>>- 별개의 큐를 두는 방법 vs 공동 큐를 사용하는 방법
>>- Symmetric Multiprocessing (SMP)
>>>- 각 프로세서가 각자 알아서 스케줄링 결정
>>- Asymmetric multiprocessing
>>>- 하나의 프로세서가 시스템 데이터의 접근과 공유를 책임지고 나머지 프로세서는 거기에 따름

<br>

[목차로 이동](#목차)

>### 실시간 스케줄링
>- Hard real-time systems (경성 실시간 시스템)
>>- 정해진 시간 안에 반드시 끝내도록 스케줄링해야 함
>- Soft real-time computing (연성 실시간 시스템)
>>- 일반 프로세스에 비해 높은 priority를 갖도록 해야함

<br>

[목차로 이동](#목차)

>### 스레드 스케줄링
>- Local Scheduling
>>- User level thread 의 경우 사용자 수준의 thread library에 의해 어떤 thread를 스케줄할지 결정
>>- 유저 프로세스가 스케줄링의 주체
>- Global Scheduling
>>- Kernel level thread의 경우 일반 프로세스와 마찬가지로 커널의 단기 스케줄러가 어떤 thread를 스케줄할지 결정
>>- 운영체제가 스레드의 존재를 알고 있기 때문에 프로세스 스케줄링 하듯이 운영체제가 알고리즘에 근거하여 결정

<br>

[목차로 이동](#목차)

>### 알고리즘 평가방법
>- Queueing models
>>- 굉장히 이론적인 방법
>>- 확률 분포로 주어지는 arrival rate와 service rate 등을 통해 각종 performance index 값을 계산
>- Implementation (구현) & Measurement (성능 측정)
>>- 실제 시스템에 알고리즘을 구현하여 실제 작업 (workload) 에 대해서 성능을 측정 비교
>- Simulation (모의 실험)
>>- 구현 및 성능 측정 방법보다 좀 더 쉬운 방법
>>- 알고리즘을 모의 프로그램으로 작성후 trace를 입력으로 하여 결과 비교

<br>

[목차로 이동](#목차)

---

## 프로세스 동기화

>### 프로세스 동기화 개요
>- 데이터의 접근
>>1. 저장장소에 데이터
>>2. 저장장소의 데이터를 읽어옴
>>3. 읽어온 데이터를 연산함
>>4. 연산 결과를 저장장소의 데이터로 저장함
>>- 혼자 사용할 때는 문제가 없으나, 여러 프로세스들이 공유 메모리를 사용하거나, 커널 내부 데이터를 사용할 경우 아무런 제약이 없다면 읽어온 시점과 저장한 시점에 따라 결과가 달라지므로 동기화 문제 (race condition, 경쟁상황) 가 발생할 가능성이 있음

<br>

[목차로 이동](#목차)

>### race condition
>- 발생 시점
>>1. kernel 수행 중 인터럽트 발생 시
>>>- 커널코드 running 중 인터럽트가 발생하면 인터럽트 처리루틴이 수행되는데 양쪽 다 커널 코드라 커널 주소 공간을 공유하기 때문에 인터럽트 핸들러의 count 값에 문제가 생김
>>>- 중요한 값을 사용하는 동안에는 인터럽트가 발생해도 인터럽트 처리루틴을 수행하는 것이아니라 disable 시켰다가 작업이 종료된 후 인터럽트 처리루틴을 실행시키는 방법으로 해결함
>>>- 결국은 순서를 정해주면 문제가 해결됨
>>2. 프로세스가 시스템 콜을 하여 커널 모드로 수행중인데 컨텍스트 스위칭이 일어나는 경우
>>>- 두 프로세스의 주소 공간끼리는 데이터 공유가 없으나, 시스템 콜을 하는 동안 커널 주소 공간속 데이터에 접근하게 되어 공유하게 되는데, 작업 중간에 CPU를 선점하면 race condition이 발생함
>>>- 커널 모드에서 수행 중일때는 CPU를 선점하지 않고, 커널 모드에서 사용자 모드로 돌아갈 때 선점하도록 하여 문제를 해결함
>>3. 멀티프로세서에서 공유 메모리 내의 커널 데이터
>>>- 어떤 CPU가 마지막으로 count를 store 했는가에 따라 race condition이 발생함
>>>- 해결방법 1 : 한번에 하나의 CPU만이 커널에 들어갈 수 있게 하는 방법
>>>>- 병목현상이 매우 심함
>>>- 해결방법 2 : 커널 내부에 있는 각 공유데이터 접근할 때마다 그 데이터에 대한 lock / unlock을 하는 방법
>- 문제 정리
>>- 공유 데이터(shared data)의 동시 접근(concurrent access)은 데이터의 불일치 문제(inconsistency)를 발생시킬 수 있음
>>- 일관성(consistency) 유지를 위해서는 협력 프로세스(cooperating process) 간의 실행 순서(orderly execution)를 정해주는 메커니즘이 필요함
>>- Race condition
>>>- 여러 프로세스들이 동시에 공유 데이터를 접근하는 상황
>>>- 데이터의 최종 연산 결과는 마지막에 그 데이터를 다룬 프로세스에 따라 달라짐
>>- race condition을 막기 위해서 concurrent process는 동기화(synchronize) 되어야 함

<br>

[목차로 이동](#목차)

>### 임계구역 문제 (The Critical-Section Problem)
>- 개요
>>- n개의 프로세스가 공유 데이터를 동시에 사용하기를 원하는 경우
>>- 각 프로세스의 code segment에는 공유 데이터를 접근하는 코드인 critical section이 존재
>>- 문제 : 하나의 프로세스가 critical section에 있을 때 다른 모든 프로세스는 critical section에 들어갈 수 없어야 함
>- 프로그램적 해결법의 충족 조건
>>- Mutual Exclusion (상호 배제)
>>>- 프로세스 P가 임계구역 부분을 수행 중이면 다른 모든 프로세스들은 그들의 임계 구역에 들어가면 안됨
>>- Progress (진행)
>>>- 아무도 임계구역에 있지 않은 상태에서 임계구역에 들어가고자 하는 프로세스가 있으면 임계구역에 들어가게 해주어야 함
>>- Bounded Waiting (한정된 대기)
>>>- 프로세스가 임계구역에 들어가려고 요청한 후부터 그 요청이 허용될 때까지 다른 프로세스들이 임계구역에 들어가는 횟수에 한계가 있어야 함
>>- 가정
>>>- 모든 프로세스의 수행 속도는 0보다 크다
>>>- 프로세스들 간의 상대적인 수행 속도는 가정하지 않는다
>- Inital Attempts to Solve Problem
>>- 프로세스들의 일반적인 구조
>>>```c
>>>do {
>>>  entry section
>>>  critical section
>>>  exit section
>>>  remainder section
>>>} while(1);
>>>```